use std::slice::Iter;

use bevy::prelude::*;
use serde::Deserialize;

use super::tick::Ticked;
use super::user::{UserOwned, UserResourceTable};
use crate::game::stages::GameStage;

/// A Resource in the game.
#[derive(Deserialize, Clone, Copy, Debug)]
pub enum Resource {
  /// The basic unit of energy.
  Watt,
  /// The basic unit of money. Generated by Headquarters.
  Credit,
}

impl Resource {
  /// A shorthand function to easily create a [ResourceDelta]
  pub fn d(self, value: i64) -> ResourceDelta {
    ResourceDelta { resource: self, value }
  }

  /// A shorthand function to generate a negative [ResourceDelta]
  pub fn cost(self, value: u32) -> ResourceDelta {
    ResourceDelta {
      resource: self,
      value: -1 * (value as i64),
    }
  }
}

/// Represents information about how a resource changes. May be used as a
/// producer (positive number) or consumer (negative number).
#[derive(Deserialize, Clone, Copy, Debug)]
pub struct ResourceDelta {
  pub resource: Resource,
  pub value: i64,
}

impl ResourceDelta {
  pub fn as_cost(self) -> Self {
    Self {
      resource: self.resource,
      value: -(self.value.abs()),
    }
  }

  pub fn as_product(self) -> Self {
    Self {
      resource: self.resource,
      value: self.value.abs(),
    }
  }
}

/// Represents a resource cost that occures when the entity is [Ticked].
#[derive(Component)]
pub struct TickedResourceCost {
  costs: Vec<ResourceDelta>,
  paid: bool,
}

impl TickedResourceCost {
  pub fn new(costs: Vec<ResourceDelta>) -> Self {
    Self { paid: false, costs }
  }

  /// Begins an iterator to verify if costs can be paid, and pay them if so.
  pub fn iter_pay_costs(&mut self) -> Iter<'_, ResourceDelta> {
    self.paid = false;
    self.costs.iter()
  }

  /// Confirms costs were paid for the pay tick.
  pub fn pay_costs(&mut self) {
    self.paid = true;
  }

  /// Were costs paid?
  pub fn paid(&self) -> bool {
    self.paid
  }
}

fn pay_ticked_resource_costs(
  mut res: ResMut<UserResourceTable>,
  mut query: Query<(&Ticked, &UserOwned, &mut TickedResourceCost)>,
) {
  query.for_each_mut(|(ticked, user, mut cost)| {
    ticked.fire(|| {
      if let Some(user) = res.get_mut(&user.0) {
        if cost
          .iter_pay_costs()
          .map(|x| user.pay_resources(x))
          .fold(true, |acc, i| acc && i)
        {
          cost.pay_costs();
        }
      } else {
        warn!(
          "Resource Cost attempted to be applied to User {}, which didn't exist.",
          user.0
        );
      }
    });
  });
}

pub struct ResourcePlugin;

impl Plugin for ResourcePlugin {
  fn build(&self, app: &mut App) {
    info!("Loading Resource System...");
    app.add_system_to_stage(GameStage::OnTicked, pay_ticked_resource_costs);
  }
}

#[cfg(test)]
mod tests {
  use bevy::prelude::*;
  use hashbrown::HashMap;
  use uuid::Uuid;

  use super::{Resource, ResourcePlugin, TickedResourceCost};
  use crate::db::models::User;
  use crate::game::stages::StagePlugin;
  use crate::game::tick::{TickPlugin, Ticked};
  use crate::game::user::{UserOwned, UserResourceTable};
  use crate::properties::GameProperties;

  #[test]
  fn test_resource_cost() {
    // Build App
    let mut app = App::new();
    app
      .add_plugins(MinimalPlugins)
      .add_plugin(StagePlugin)
      .add_plugin(TickPlugin)
      .add_plugin(ResourcePlugin)
      .init_resource::<GameProperties>();

    let id = Uuid::new_v4();
    let user = User { id, credits: 14 };

    // Insert a User with Data
    app
      .world
      .insert_resource(UserResourceTable::new(HashMap::from([(id, user)])));

    // Produce an entity with a ticked cost.
    let building = app
      .world
      .spawn((
        Ticked::every_tick(),
        UserOwned(id),
        TickedResourceCost::new(vec![Resource::Credit.cost(5)]),
      ))
      .id();

    // Pay Cost #1
    app.update();

    let cost: &TickedResourceCost = app.world.entity(building).get().unwrap();
    assert!(cost.paid());

    let user_table: &UserResourceTable = app.world.get_resource().unwrap();
    assert_eq!(user_table.get(&id).unwrap().credits, 9);

    // Pay Cost #2
    app.update();

    let cost: &TickedResourceCost = app.world.entity(building).get().unwrap();
    assert!(cost.paid());

    let user_table: &UserResourceTable = app.world.get_resource().unwrap();
    assert_eq!(user_table.get(&id).unwrap().credits, 4);

    // Pay Cost #3, cannot pay
    app.update();

    let cost: &TickedResourceCost = app.world.entity(building).get().unwrap();
    assert!(!cost.paid());

    let user_table: &UserResourceTable = app.world.get_resource().unwrap();
    assert_eq!(user_table.get(&id).unwrap().credits, 4);
  }
}
